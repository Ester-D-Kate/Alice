<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Alice AI Assistant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Base styles for light mode */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Light gray background */
            color: #1f2937; /* Dark gray text */
            transition: background-color 0.3s ease, color 0.3s ease;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            overscroll-behavior: contain;
        }
        .container {
            max-width: 800px;
            background-color: #ffffff; /* White background for container */
            transition: background-color 0.3s ease;
            margin: 0 auto;
            width: 100%;
            min-height: calc(100vh - 2rem);
        }
        
        /* Mobile specific styles */
        .mobile-device .container {
            box-shadow: none;
        }
        
        @media (max-width: 640px) {
            .container {
                margin: 0;
                border-radius: 0;
                min-height: 100vh;
                padding: 1rem;
            }
            
            h1 {
                font-size: 1.75rem;
                margin-bottom: 1.5rem;
            }
            
            .button-group {
                flex-direction: column;
                gap: 1rem;
            }
            
            .button-group button {
                width: 100%;
                padding: 1rem 2rem;
                font-size: 1.1rem;
                min-height: 60px;
                border-radius: 12px;
                font-weight: 600;
            }
            
            .button-group button:active {
                transform: scale(0.98);
            }
        }
        .script-display {
            background-color: #f3f4f6; /* Light gray for script display */
            color: #1f2937; /* Dark text for script display */
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        h1, h2 {
            color: #1f2937; /* Dark text for headings */
            transition: color 0.3s ease;
        }
        p {
            color: #4b5563; /* Medium gray for paragraphs */
            transition: color 0.3s ease;
        }

        /* Dark mode styles - applied when 'dark' class is on <html> */
        html.dark body {
            background-color: #1a202c; /* Dark background */
            color: #e0e0e0; /* Light gray text */
        }
        html.dark .container {
            background-color: #2d3748; /* Darker background for container */
        }
        html.dark .script-display {
            background-color: #4a5568; /* Even darker for script display */
            color: #e0e0e0; /* Light text for script display */
        }
        html.dark h1, html.dark h2 {
            color: #e0e0e0; /* Light text for headings */
        }
        html.dark p {
            color: #a0aec0; /* Lighter gray for paragraphs */
        }

        /* Custom scrollbar for the script display area (adjust for dark mode) */
        .script-display::-webkit-scrollbar {
            width: 8px;
        }
        .script-display::-webkit-scrollbar-track {
            background: #e0e0e0; /* Light mode track */
            border-radius: 10px;
        }
        .script-display::-webkit-scrollbar-thumb {
            background: #9ca3af; /* Light mode thumb */
            border-radius: 10px;
        }
        .script-display::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* Light mode thumb hover */
        }

        html.dark .script-display::-webkit-scrollbar-track {
            background: #2d3748; /* Dark mode track */
        }
        html.dark .script-display::-webkit-scrollbar-thumb {
            background: #718096; /* Dark mode thumb */
        }
        html.dark .script-display::-webkit-scrollbar-thumb:hover {
            background: #a0aec0; /* Dark mode thumb hover */
        }

        /* Dark mode toggle button specific styles */
        #theme-toggle {
            background-color: #cbd5e0; /* Light gray for toggle in light mode */
            color: #4a5568; /* Dark text for toggle in light mode */
            transition: background-color 0.3s ease, color 0.3s ease, transform 0.2s ease;
        }
        #theme-toggle:hover {
            background-color: #a0aec0;
        }
        html.dark #theme-toggle {
            background-color: #4a5568; /* Darker gray for toggle in dark mode */
            color: #e0e0e0; /* Light text for toggle in dark mode */
        }
        html.dark #theme-toggle:hover {
            background-color: #718096;
        }
        
        /* Mobile touch styles */
        @media (max-width: 768px) {
            button {
                -webkit-tap-highlight-color: rgba(0, 0, 0, 0.1);
                touch-action: manipulation;
            }
            
            .script-display {
                max-height: 150px;
                font-size: 0.9rem;
            }
            
            #theme-toggle {
                top: 1rem;
                right: 1rem;
                padding: 0.75rem;
            }
        }
        
        /* Prevent zoom on input focus for iOS */
        @media screen and (-webkit-min-device-pixel-ratio: 0) {
            select, textarea, input[type="text"], input[type="password"], 
            input[type="datetime"], input[type="datetime-local"], 
            input[type="date"], input[type="month"], input[type="time"], 
            input[type="week"], input[type="number"], input[type="email"], 
            input[type="url"] {
                font-size: 16px;
            }
        }
        
        /* Recording animation */
        @keyframes pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
            }
            70% {
                transform: scale(1.05);
                box-shadow: 0 0 0 10px rgba(239, 68, 68, 0);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
            }
        }
        
        /* Loading spinner animation */
        @keyframes spin {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }
        
        .animate-spin {
            animation: spin 1s linear infinite;
        }
        
        .flex {
            display: flex;
        }
        
        .items-center {
            align-items: center;
        }
        
        .justify-center {
            justify-content: center;
        }
        
        .gap-2 {
            gap: 0.5rem;
        }
        
        .h-4 {
            height: 1rem;
        }
        
        .w-4 {
            width: 1rem;
        }
        
        .border-b-2 {
            border-bottom-width: 2px;
        }
        
        .border-blue-600 {
            border-color: #2563eb;
        }
        
        .rounded-full {
            border-radius: 9999px;
        }
        
        .text-red-600 {
            color: #dc2626;
        }
        
        .font-semibold {
            font-weight: 600;
        }
        
        .mb-2 {
            margin-bottom: 0.5rem;
        }
        
        .text-sm {
            font-size: 0.875rem;
        }
        
        .text-xs {
            font-size: 0.75rem;
        }
        
        .text-gray-600 {
            color: #4b5563;
        }
        
        .space-y-1 > * + * {
            margin-top: 0.25rem;
        }
        
        .text-center {
            text-align: center;
        }
        
        code {
            background-color: #f3f4f6;
            padding: 0.125rem 0.25rem;
            border-radius: 0.25rem;
            font-family: monospace;
            font-size: 0.875rem;
        }
        
        html.dark code {
            background-color: #374151;
            color: #e5e7eb;
        }
        
        /* Improved mobile accessibility */
        @media (max-width: 480px) {
            .container {
                padding: 0.75rem;
            }
            
            h1 {
                font-size: 1.5rem;
            }
            
            .script-display {
                font-size: 0.85rem;
                padding: 0.75rem;
                max-height: 120px;
            }
            
            #status-message {
                font-size: 0.9rem;
                padding: 0.5rem;
                margin: 0.75rem 0;
            }
        }
        
        /* Safe area handling for notched devices */
        @supports (padding-top: constant(safe-area-inset-top)) {
            .container {
                padding-top: constant(safe-area-inset-top);
                padding-left: constant(safe-area-inset-left);
                padding-right: constant(safe-area-inset-right);
                padding-bottom: constant(safe-area-inset-bottom);
            }
        }
        
        @supports (padding-top: env(safe-area-inset-top)) {
            .container {
                padding-top: env(safe-area-inset-top);
                padding-left: env(safe-area-inset-left);
                padding-right: env(safe-area-inset-right);
                padding-bottom: env(safe-area-inset-bottom);
            }
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">
    <div class="container bg-white p-8 rounded-xl shadow-lg w-full relative">
        <button id="theme-toggle" class="absolute top-4 right-4 p-2 rounded-full shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-400">
            <svg id="sun-icon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h1M3 12h1m15.325-7.757l-.707.707M5.388 18.325l-.707.707M18.325 5.388l.707-.707M5.388 5.388l.707-.707M12 18a6 6 0 100-12 6 6 0 000 12z"></path>
            </svg>
            <svg id="moon-icon" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path>
            </svg>
        </button>

        <h1 class="text-3xl font-bold text-center mb-8">Alice AI Assistant</h1>

        <p id="status-message" class="text-center text-gray-600 mb-6"></p>

        <!-- AI Natural Response Section -->
        <div class="mb-6">
            <h2 class="text-xl font-semibold mb-4">Alice's Response:</h2>
            <div id="response-display" class="script-display bg-gray-100 p-4 rounded-lg border border-gray-300 min-h-[80px] max-h-[200px] overflow-y-auto whitespace-pre-wrap">
                Ask me something by recording your voice!
            </div>
        </div>

        <!-- Ducky Script Section -->
        <div class="mb-6" id="ducky-script-section" style="display: none;">
            <h2 class="text-xl font-semibold mb-4">Computer Control Script:</h2>
            <div id="script-display" class="script-display bg-gray-100 p-4 rounded-lg border border-gray-300 min-h-[100px] max-h-[200px] overflow-y-auto whitespace-pre-wrap">
                No script generated yet.
            </div>
        </div>

        <!-- Appliance Control Section -->
        <div class="mb-6" id="appliance-control-section" style="display: none;">
            <h2 class="text-xl font-semibold mb-4">Smart Home Control:</h2>
            <div id="appliance-display" class="script-display bg-gray-100 p-4 rounded-lg border border-gray-300 min-h-[50px] max-h-[150px] overflow-y-auto">
                <ul id="appliance-list" class="list-disc pl-5">
                    <!-- Appliance controls will be added here -->
                </ul>
            </div>
        </div>

        <div class="button-group flex flex-col sm:flex-row justify-center items-center gap-4 mt-8">
            <div class="flex flex-col items-center w-full sm:w-auto">
                <button id="record-button" class="bg-blue-600 hover:bg-blue-700 active:bg-blue-800 text-white font-semibold py-3 px-8 rounded-full shadow-md transition duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 w-full sm:w-auto">
                    ðŸŽ¤ Start Recording
                </button>
                <p class="text-sm text-gray-500 mt-2 text-center">Tap to start/stop recording</p>
            </div>

            <div class="flex flex-col items-center w-full sm:w-auto">
                <button id="send-script-button" class="bg-green-600 hover:bg-green-700 active:bg-green-800 text-white font-semibold py-3 px-8 rounded-full shadow-md transition duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50 disabled:opacity-50 disabled:cursor-not-allowed w-full sm:w-auto" disabled>
                    âš¡ Execute Commands
                </button>
                <p class="text-sm text-gray-500 mt-2 text-center">Review before executing</p>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration ---
        // IMPORTANT: Replace these with your actual server URLs
        const AI_SERVER_URL = 'http://127.0.0.1:8000/api/v1/audio/process_audio';  // Updated to match your API endpoint
        const COMPUTER_EXECUTION_URL = 'http://127.0.0.1:8000/execute_command'; // Replace with your ESP/device URL
        const LAPTOP_CONTROL_PASSWORD = 'E1s2t3e4r5'; // Password for laptop control authentication

        // --- DOM Elements ---
        const htmlElement = document.documentElement;
        const themeToggle = document.getElementById('theme-toggle');
        const sunIcon = document.getElementById('sun-icon');
        const moonIcon = document.getElementById('moon-icon');
        const recordButton = document.getElementById('record-button');
        const statusMessage = document.getElementById('status-message');
        const responseDisplay = document.getElementById('response-display');
        const scriptDisplay = document.getElementById('script-display');
        const duckyScriptSection = document.getElementById('ducky-script-section');
        const applianceControlSection = document.getElementById('appliance-control-section');
        const applianceList = document.getElementById('appliance-list');
        const sendScriptButton = document.getElementById('send-script-button');

        // --- Response Data Storage ---
        let currentResponseData = null;

        // --- Media Recorder Variables ---
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;

        // --- Theme Management Functions ---
        /**
         * Applies the selected theme based on the 'theme' class on the <html> element.
         * Updates the visibility of sun/moon icons.
         * @param {string} theme - 'light' or 'dark'
         */
        function applyTheme(theme) {
            if (theme === 'dark') {
                htmlElement.classList.add('dark');
                sunIcon.classList.add('hidden');
                moonIcon.classList.remove('hidden');
            } else {
                htmlElement.classList.remove('dark');
                sunIcon.classList.remove('hidden');
                moonIcon.classList.add('hidden');
            }
            localStorage.setItem('theme', theme); // Save preference
        }

        /**
         * Toggles the theme between light and dark.
         */
        function toggleTheme() {
            if (htmlElement.classList.contains('dark')) {
                applyTheme('light');
            } else {
                applyTheme('dark');
            }
        }

        // --- Initialize Theme on Load ---
        // Check local storage for user's preferred theme
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme) {
            applyTheme(savedTheme);
        } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            // If no preference saved, check system preference
            applyTheme('dark');
        } else {
            applyTheme('light'); // Default to light mode
        }

        // --- Mobile Initialization ---
        /**
         * Initialize mobile-specific features and check permissions
         */
        async function initializeMobileFeatures() {
            // Check if we're on a mobile device
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (isMobile) {
                // Add mobile-specific class for styling
                document.body.classList.add('mobile-device');
                
                // Check microphone permission status
                if (navigator.permissions) {
                    try {
                        const permission = await navigator.permissions.query({ name: 'microphone' });
                        updatePermissionStatus(permission.state);
                        
                        // Listen for permission changes
                        permission.onchange = () => {
                            updatePermissionStatus(permission.state);
                        };
                    } catch (error) {
                        console.log('Permission API not supported:', error);
                    }
                }
                
                // Prevent pull-to-refresh on mobile
                document.body.addEventListener('touchstart', e => {
                    if (e.touches.length > 1) {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                document.body.addEventListener('touchend', e => {
                    const now = (new Date()).getTime();
                    if (now - lastTouchEnd <= 300) {
                        e.preventDefault();
                    }
                    lastTouchEnd = now;
                }, false);
            }
            
            // Check audio support and update UI accordingly
            const supportCheck = checkAudioSupport();
            if (!supportCheck.supported) {
                if (supportCheck.isHttpsIssue) {
                    statusMessage.innerHTML = `
                        <div class="text-center">
                            <p class="text-red-600 font-semibold mb-2">ðŸ”’ HTTPS Required for Mobile Microphone Access</p>
                            <p class="text-sm mb-2">Mobile browsers require HTTPS for security.</p>
                            <div class="text-xs text-gray-600 space-y-1">
                                <p><strong>Solutions:</strong></p>
                                <p>1. Use <code>https://</code> instead of <code>http://</code></p>
                                <p>2. Access via <code>localhost</code> on the same device</p>
                                <p>3. Set up SSL certificate for your server</p>
                            </div>
                        </div>
                    `;
                } else {
                    statusMessage.textContent = `Audio not supported: ${supportCheck.reason}`;
                }
                recordButton.disabled = true;
                recordButton.innerHTML = 'ðŸ”’ HTTPS Required';
                recordButton.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                recordButton.classList.add('bg-red-600', 'hover:bg-red-700');
            }
        }

        let lastTouchEnd = 0;

        /**
         * Update UI based on microphone permission status
         */
        function updatePermissionStatus(state) {
            switch (state) {
                case 'granted':
                    statusMessage.textContent = 'Microphone ready! Tap to start recording.';
                    break;
                case 'denied':
                    statusMessage.textContent = 'Microphone access denied. Please enable in browser settings.';
                    break;
                case 'prompt':
                    statusMessage.textContent = 'Microphone permission required. Tap record to allow access.';
                    break;
                default:
                    statusMessage.textContent = 'Ready to record audio commands.';
            }
        }

        // Initialize mobile features when DOM is loaded
        document.addEventListener('DOMContentLoaded', initializeMobileFeatures);

        // Add connection status monitoring for mobile networks
        function updateConnectionStatus() {
            if (navigator.onLine) {
                if (statusMessage.textContent.includes('offline')) {
                    statusMessage.textContent = 'Connection restored! Ready to record.';
                }
            } else {
                statusMessage.textContent = 'You are offline. Please check your internet connection.';
                recordButton.disabled = true;
                sendScriptButton.disabled = true;
            }
        }

        // Listen for connection changes (important for mobile)
        window.addEventListener('online', () => {
            recordButton.disabled = false;
            updateConnectionStatus();
        });

        window.addEventListener('offline', updateConnectionStatus);

        // Initialize connection status
        updateConnectionStatus();

        // --- Event Listeners ---
        themeToggle.addEventListener('click', toggleTheme);

        recordButton.addEventListener('click', () => {
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        });

        sendScriptButton.addEventListener('click', () => {
            executeCommands();
        });

        // --- Functions ---

        /**
         * Checks if the device supports audio recording
         */
        function checkAudioSupport() {
            // Check if we're on HTTPS or localhost
            const isSecureContext = window.isSecureContext || location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
            
            if (!isSecureContext) {
                return { 
                    supported: false, 
                    reason: 'HTTPS required for microphone access on mobile devices',
                    isHttpsIssue: true 
                };
            }
            
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                return { 
                    supported: false, 
                    reason: 'MediaDevices API not supported in this browser',
                    isHttpsIssue: false 
                };
            }
            if (!window.MediaRecorder) {
                return { 
                    supported: false, 
                    reason: 'MediaRecorder API not supported in this browser',
                    isHttpsIssue: false 
                };
            }
            return { supported: true };
        }

        /**
         * Starts the audio recording process.
         * Requests microphone access and initializes MediaRecorder.
         */
        async function startRecording() {
            // Check browser support first
            const supportCheck = checkAudioSupport();
            if (!supportCheck.supported) {
                statusMessage.textContent = `Error: ${supportCheck.reason}. Please use a modern browser.`;
                return;
            }

            try {
                // Show permission request message for mobile
                statusMessage.textContent = 'Requesting microphone permission...';
                
                // Request access to the user's microphone with mobile-friendly constraints
                const constraints = {
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        // Mobile-specific optimizations
                        sampleRate: 16000,
                        channelCount: 1
                    }
                };

                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // Determine the best audio format for the device
                let mimeType = 'audio/webm';
                if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
                    mimeType = 'audio/webm;codecs=opus';
                } else if (MediaRecorder.isTypeSupported('audio/mp4')) {
                    mimeType = 'audio/mp4';
                } else if (MediaRecorder.isTypeSupported('audio/ogg;codecs=opus')) {
                    mimeType = 'audio/ogg;codecs=opus';
                }

                mediaRecorder = new MediaRecorder(stream, { mimeType });
                audioChunks = []; // Clear previous audio chunks

                // Event listener for when audio data is available
                mediaRecorder.ondataavailable = event => {
                    if (event.data && event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                // Event listener for when recording stops
                mediaRecorder.onstop = () => {
                    if (audioChunks.length === 0) {
                        statusMessage.textContent = 'No audio was recorded. Please try again.';
                        return;
                    }
                    
                    const audioBlob = new Blob(audioChunks, { type: mimeType });
                    sendAudioToAI(audioBlob); // Send the audio to the AI server
                    
                    // Stop all tracks in the stream to release microphone
                    stream.getTracks().forEach(track => track.stop());
                };

                // Start recording with error handling
                mediaRecorder.start(100); // Collect data every 100ms
                isRecording = true;
                recordButton.innerHTML = 'ðŸ”´ Stop Recording';
                recordButton.classList.remove('bg-blue-600', 'hover:bg-blue-700', 'active:bg-blue-800');
                recordButton.classList.add('bg-red-600', 'hover:bg-red-700', 'active:bg-red-800');
                statusMessage.textContent = 'Recording... Tap again to stop.';
                responseDisplay.textContent = 'Recording started... Waiting for AI response.';
                sendScriptButton.disabled = true; // Disable send button while recording/waiting
                
                // Add visual feedback for recording
                recordButton.style.animation = 'pulse 1s infinite';
                
            } catch (error) {
                console.error('Error accessing microphone:', error);
                
                let errorMessage = 'Could not access microphone. ';
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    errorMessage += 'Please allow microphone access and try again.';
                } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    errorMessage += 'No microphone found on this device.';
                } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                    errorMessage += 'Microphone is being used by another application.';
                } else if (error.name === 'OverconstrainedError' || error.name === 'ConstraintNotSatisfiedError') {
                    errorMessage += 'Microphone constraints not supported.';
                } else {
                    errorMessage += 'Please check your device settings.';
                }
                
                statusMessage.textContent = errorMessage;
                recordButton.classList.remove('bg-red-600', 'hover:bg-red-700', 'active:bg-red-800');
                recordButton.classList.add('bg-blue-600', 'hover:bg-blue-700', 'active:bg-blue-800');
                recordButton.innerHTML = 'ðŸŽ¤ Start Recording';
                recordButton.style.animation = '';
                isRecording = false;
            }
        }

        /**
         * Stops the audio recording process.
         */
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop(); // This will trigger the onstop event
                isRecording = false;
                recordButton.innerHTML = 'ðŸŽ¤ Start Recording';
                recordButton.classList.remove('bg-red-600', 'hover:bg-red-700', 'active:bg-red-800');
                recordButton.classList.add('bg-blue-600', 'hover:bg-blue-700', 'active:bg-blue-800');
                recordButton.style.animation = '';
                statusMessage.textContent = 'Recording stopped. Sending audio to AI...';
            }
        }

        /**
         * Shows a loading indicator
         */
        function showLoading(message) {
            statusMessage.textContent = message || 'Processing...';
            statusMessage.innerHTML = `
                <div class="flex items-center justify-center gap-2">
                    <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
                    <span>${message || 'Processing...'}</span>
                </div>
            `;
        }

        /**
         * Sends the recorded audio Blob to the AI server.
         * Now expects a JSON response from the backend.
         * @param {Blob} audioBlob - The recorded audio data.
         */
        async function sendAudioToAI(audioBlob) {
            // Validate audio blob
            if (!audioBlob || audioBlob.size === 0) {
                statusMessage.textContent = 'No audio recorded. Please try again.';
                return;
            }

            showLoading('Sending audio to AI...');
            
            const formData = new FormData();
            // Use the actual mime type of the recorded blob
            const fileName = `audio.${audioBlob.type.includes('mp4') ? 'mp4' : 'webm'}`;
            formData.append('audio_file', audioBlob, fileName);

            try {
                // Add timeout for mobile networks
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout

                const response = await fetch(AI_SERVER_URL, {
                    method: 'POST',
                    body: formData,
                    signal: controller.signal,
                });

                clearTimeout(timeoutId);

                if (!response.ok) {
                    let errorMessage = `Server error (${response.status})`;
                    try {
                        const errorData = await response.text();
                        if (errorData) {
                            errorMessage += `: ${errorData}`;
                        }
                    } catch (e) {
                        // Ignore JSON parse errors for error responses
                    }
                    throw new Error(errorMessage);
                }

                // Changed from .text() to .json() to match our updated backend
                const responseData = await response.json();
                currentResponseData = responseData; // Store the response data

                // Display the different parts of the response
                displayAIResponse(responseData);
                
                statusMessage.textContent = 'âœ… AI response received! Review before executing commands.';
                
                // Enable or disable the execute button based on whether there are commands to execute
                sendScriptButton.disabled = !(responseData.output_ducky_script || 
                                            Object.keys(responseData.output_appliances_response || {}).length > 0);
                
            } catch (error) {
                console.error('Error sending audio to AI server:', error);
                
                let errorMessage = 'Failed to process audio. ';
                if (error.name === 'AbortError') {
                    errorMessage += 'Request timed out. Please check your connection and try again.';
                } else if (error.message.includes('Failed to fetch')) {
                    errorMessage += 'Cannot connect to server. Please check your internet connection.';
                } else {
                    errorMessage += error.message;
                }
                
                statusMessage.textContent = `âŒ ${errorMessage}`;
                responseDisplay.textContent = 'Failed to get AI response. Please try recording again.';
                sendScriptButton.disabled = true;
            }
        }

        /**
         * Displays the AI response data in the appropriate sections.
         * @param {Object} responseData - The JSON response from the AI server.
         */
// Inside the displayAIResponse function in your HTML file

function displayAIResponse(responseData) {
    console.log("Full response data:", responseData);  // Add this for debugging
    
    // Display natural response
    if (responseData.output_natural_response) {
        responseDisplay.textContent = responseData.output_natural_response;
    } else {
        responseDisplay.textContent = "I'm processing your request...";
    }

    // Display ducky script if present
    if (responseData.output_ducky_script) {
        scriptDisplay.textContent = responseData.output_ducky_script;
        duckyScriptSection.style.display = 'block';
    } else {
        duckyScriptSection.style.display = 'none';
    }

    // Display appliance controls if present
    const applianceControls = responseData.output_appliances_response || {};
    if (Object.keys(applianceControls).length > 0) {
        applianceList.innerHTML = ''; // Clear previous controls
        
        for (const [device, state] of Object.entries(applianceControls)) {
            const listItem = document.createElement('li');
            listItem.textContent = `${device}: ${state}`;
            listItem.className = state === 'on' ? 'text-green-600' : 'text-red-600';
            applianceList.appendChild(listItem);
        }
        
        applianceControlSection.style.display = 'block';
    } else {
        applianceControlSection.style.display = 'none';
    }

    // Add a "Raw Response" section for debugging
    const debugSection = document.getElementById('debug-section') || createDebugSection();
    const debugContent = document.getElementById('debug-content');
    debugContent.textContent = JSON.stringify(responseData, null, 2);
}

function createDebugSection() {
    const section = document.createElement('div');
    section.id = 'debug-section';
    section.className = 'mb-6 mt-4 pt-4 border-t border-gray-300';
    
    const heading = document.createElement('h2');
    heading.className = 'text-xl font-semibold mb-4 flex items-center';
    heading.innerHTML = 'Debug: Raw Response <span class="text-sm font-normal ml-2">(click to toggle)</span>';
    
    const content = document.createElement('pre');
    content.id = 'debug-content';
    content.className = 'script-display bg-gray-100 p-4 rounded-lg border border-gray-300 max-h-[200px] overflow-y-auto text-xs';
    content.style.display = 'none'; // Hidden by default
    
    heading.addEventListener('click', () => {
        content.style.display = content.style.display === 'none' ? 'block' : 'none';
    });
    
    section.appendChild(heading);
    section.appendChild(content);
    document.querySelector('.container').appendChild(section);
    
    return section;
}

        /**
         * Sends commands (ducky script or appliance controls) to the execution endpoint.
         */
        async function executeCommands() {
            if (!currentResponseData) {
                statusMessage.textContent = 'No commands to execute.';
                return;
            }

            statusMessage.textContent = 'Sending commands for execution...';
            sendScriptButton.disabled = true; // Disable button to prevent multiple sends

            try {
                const response = await fetch(COMPUTER_EXECUTION_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        ducky_script: currentResponseData.output_ducky_script || "",
                        password: LAPTOP_CONTROL_PASSWORD,
                        repeat: true,  // Temporarily allow repeats for testing
                        appliance_controls: currentResponseData.output_appliances_response || {}
                    }),
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();

                statusMessage.textContent = `Commands executed successfully! Response: ${result.message || JSON.stringify(result)}`;
            } catch (error) {
                console.error('Error executing commands:', error);
                statusMessage.textContent = `Error executing commands: ${error.message}.`;
            } finally {
                sendScriptButton.disabled = false; // Re-enable the button
            }
        }
    </script>
</body>
</html>